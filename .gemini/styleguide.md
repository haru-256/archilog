# プロジェクト開発スタイルガイド

> 🤖 **AI向けの重要な情報**
> このスタイルガイドは、AIアシスタント（特にGoogle Gemini）がコード生成・提案を行う際の参照ドキュメントとして作成されています。
> コード生成・提案時は、このドキュメントの原則を必ず遵守してください。

## 1. 基本方針

### 1.1. 目的と価値観

- **品質重視**: コードの品質、保守性、一貫性を向上させ、長期的な開発効率を追求する。
- **チーム成長**: 開発者の技術的成長を支援し、知識の共有を促進する
- **ユーザー価値**: 最終的にはユーザーに価値を提供することを最優先とする

### 1.2. コミュニケーション指針

- **言語**: レビュー、コメント、ドキュメントは日本語で統一
- **建設的姿勢**: 問題指摘時は必ず改善案とその理由を併記
- **学習支援**: 関連するベストプラクティスや学習リソースを積極的に共有
- **心理的安全性**: 質問や議論を歓迎し、失敗から学ぶ文化を醸成

## 2. コードレビューガイドライン

> 📋 **このセクションのサマリー**
> 効果的なコードレビューの手法を定義。優先度付きの観点、構造化されたコメント手法、ポジティブフィードバックの重要性を説明します。

コードレビューは単なる品質チェックではなく、知識共有とチーム学習の貴重な機会です。レビュワーは教師として、レビュイーは学習者として、互いに成長できる場にします。効果的なレビューは、コードの品質向上だけでなく、チーム全体の技術力底上げにも寄与します。

### 2.1. レビューの優先順位

レビューでは無数の改善点が見つかりますが、すべてを同じ重要度で扱うと、本質的な問題が見落とされがちです。以下の優先順位に従って、重要な問題から順に取り組みます：

以下の観点を**優先度順**で評価し、レビューコメントを作成する。

| 優先度 | 観点 | チェック項目例 | 影響範囲 |
| :---: | :--- | :--- | :--- |
| **🔴 最高** | **Correctness (正確性)** | 仕様を満たしているか？バグやエッジケースは考慮されているか？ | ユーザー体験直結 |
| **🟠 高** | **Security (セキュリティ)** | SQLインジェクション等の脆弱性はないか？入力値のバリデーションは適切か？ | システム全体 |
| **🟡 中高** | **Performance (パフォーマンス)** | 非効率なアルゴリズムはないか？N+1問題やメモリリークはないか？ | システム性能 |
| **🔵 中** | **Maintainability (保守性)** | 責務は適切に分離されているか？将来の変更は容易か？複雑度は適切か？ | 開発効率 |
| **🟢 低** | **Readability (可読性)** | 命名は適切か？ロジックは追いやすいか？コメントは必要十分か？ | 開発者体験 |
| **⚪ 最低** | **Consistency (一貫性)** | プロジェクトのコーディング規約や設計パターンに準拠しているか？ | コード統一性 |

### 2.2. レビュー時の着眼点

#### 🎯 特に注目すべきポイント

- **エラーハンドリング**: 例外的なケースでの動作は安全か？
- **リソース管理**: DB接続、ファイルハンドル、goroutineの適切なクリーンアップ
- **並行処理**: データ競合やデッドロックの可能性はないか？
- **テスト容易性**: モックやスタブが使いやすい設計になっているか？

## 3. 効果的なレビューコメントの書き方

> 📋 **このセクションのサマリー**
> 建設的で実用的なレビューコメントの作成方法。STARメソッドによる構造化、重要度の明示、学習リソースの提供を通じて、真に価値あるフィードバックを実現します。

レビューコメントは、相手に行動を促す重要なコミュニケーションツールです。単なる指摘ではなく、相手の理解を深め、具体的な改善行動につながるコメントを心がけます。効果的なコメントは、即座に問題を解決するだけでなく、将来的に同様の問題を避ける学習効果も生み出します。

### 3.1. 重要度の明示とアクションの明確化

コメントを受ける側が適切な優先順位で対応できるよう、重要度とアクションを明確に示します。これにより、限られた時間の中で最も効果的な改善が可能になります：

コメントには重要度と必要なアクションを明記し、開発者が優先順位を判断できるようにする。

| 重要度 | アクション | 対象例 | タイムライン |
| :---: | :--- | :--- | :--- |
| **🔴 CRITICAL** | **マージ前に必須修正** | バグ、セキュリティ脆弱性、データ破損リスク | 即座 |
| **🟠 HIGH** | **マージ前の修正を強く推奨** | パフォーマンス問題、保守性の問題 | 24時間以内 |
| **🟡 MEDIUM** | **次回イテレーションで修正** | リファクタリング、テスト追加 | 1週間以内 |
| **🟢 LOW** | **時間のあるときに修正** | 命名改善、コメント追加 | バックログ |
| **🔵 INFO** | **情報提供・質問** | ベストプラクティス紹介、代替手法の提案 | - |

### 3.2. 効果的なコメントの構造

コメントは以下の**STARメソッド**で構成する。

```markdown
🎨 **[SEVERITY] 状況 (Situation)**
🔍 **原因 (Task/Problem)**
📝 **提案 (Action)**
🎆 **期待される結果 (Result)**
```

悪い例：指摘のみ

```markdown
この変数名は分かりにくい。
```

良い例：STARメソッド適用

```markdown
🎨 **[LOW] 変数名の可読性問題**
変数 `d` が何を表しているのかが一目でわかりません。

🔍 **原因**
短い略記名はコードの可読性を下げ、メンテナンスコストを増加させます。

📝 **提案**

\`\`\`go
// Before
d := time.Since(startTime)

// After
elapsedTimeInSeconds := time.Since(startTime)
\`\`\`

🎆 **期待される結果**
コードの意図が明確になり、新しいメンバーでも理解しやすくなります。
```

### 3.3. コード例とリソースの提供

#### コード例のベストプラクティス

1. **Before/After形式**: 現在のコードと改善後のコードを並べて表示
2. **実行可能なコード**: コピー＆ペーストですぐに試せるように
3. **コメント付き**: 重要な部分には説明コメントを追加

#### 学習リソースの提供

コメントには関連する学習リソースを積極的に含める。

- **公式ドキュメント**: Goの公式ドキュメントやEffective Goへのリンク
- **ベストプラクティス記事**: 信頼できる技術ブログや書籍への参照
- **内部リソース**: プロジェクト内の関連コードやドキュメントへのリンク

### 3.4. ポジティブフィードバックの実践

#### 認めるべき優れた点

- **✨ 優雅な設計**: シンプルで理解しやすいアーキテクチャ
- **🎨 美しいコード**: 読みやすく、一貫性のあるコード
- **🔧 巧妙な解法**: パフォーマンスやメモリ効率を考慮した実装
- **🛡️ 強固なエラーハンドリング**: 例外的ケースを適切に処理
- **🧪 網羅的なテスト**: エッジケースを含む十分なテストカバレッジ

#### ポジティブコメントの例

```markdown
🎆 **素晴らしい実装です！**
このコンテキストパッケージの設計は、タイムアウトとキャンセルを適切に処理しており、Goのベストプラクティスに完全に準拠しています。

特に、deferを使ったリソースのクリーンアップが美しく、メモリリークやゴルーチンリークの心配がありません。

📚 **参考**: [Effective Go - コンテキスト](https://golang.org/doc/effective_go#concurrency)
```

## 5. 🚀 まとめとベストプラクティス

> 📋 **このセクションのサマリー**
> プロジェクト全体を通じて重要な原則とチェックリストをまとめ。日常的な開発からリリースまで、品質を保つためのガイダンスを提供します。

このスタイルガイドで説明した各要素は、独立したテクニックではなく、相互に関連し合うシステムです。コードレビューの文化、技術的な実装パターン、チームコミュニケーションが組み合わさることで、初めて持続可能で価値ある開発が実現されます。

**スタイルガイドの真の目的：**

1. **効率性の向上**: 一貫したパターンにより、認知負荷を減らし開発速度を向上
2. **品質の保証**: 体系的なアプローチで、バグや設計問題を早期に発見・修正
3. **知識の共有**: チーム全体で技術的な知見を共有し、集合知を活用
4. **持続可能性**: 長期的にメンテナンスしやすいコードベースの構築

### 5.1. 重要な原則

以下の原則は、すべての技術的判断の基盤となります：

1. **シンプルさを優先** - 複雑さよりもシンプルさを選ぶ
2. **一貫性を維持** - プロジェクト全体で統一されたスタイルを保つ
3. **フィードバックを大切に** - 建設的な議論で品質を向上
4. **継続的改善** - 小さな改善を積み重ねる
5. **インターフェースを受け入れ、具象を返す** - Goの設計思想に従い、柔軟で保守性の高いコードを書く

#### 🎯 Go設計思想：「インターフェースを受け入れ、具象（struct）を返す」

コンストラクタやファクトリー関数を設計する際の重要な原則：

**✅ 推奨パターン：**

```go
// コンストラクタはインターフェースを受け取り、具象型を返す
func NewProductServiceImpl(
    repo ProductRepository,  // インターフェースを受け入れる
    logger *slog.Logger,
) *ProductServiceImpl {      // 具象型を返す
    return &ProductServiceImpl{
        repo:   repo,
        logger: logger,
    }
}
```

**❌ 非推奨パターン：**

```go
// インターフェースを返すと呼び出し側の柔軟性が失われる
func NewProductService(
    repo ProductRepository,
    logger *slog.Logger,
) ProductService {  // インターフェースを返す（推奨されない）
    return &ProductServiceImpl{
        repo:   repo,
        logger: logger,
    }
}
```

**この原則の利点：**

- **呼び出し側の自由度**: 具象型を受け取り、必要に応じてインターフェースとして扱える
- **実装の明確性**: コンストラクタ名（`NewXxxImpl`）で具象型を返すことが明示される
- **DIフレームワークとの親和性**: Uber Fxの`fx.As`で簡単にインターフェースに変換できる
- **デバッグの容易性**: 実際の型情報が保持され、トラブルシューティングが容易

> 💡 **Gemini向けの実装ガイド**
> コード生成時は、必ずコンストラクタ名に`Impl`サフィックスを付け（例：`NewProductServiceImpl`）、具象型（例：`*ProductServiceImpl`）を返してください。Fxモジュールでは`fx.Annotate`と`fx.As`を使用してインターフェースに変換します。

### 5.2. チェックリスト

#### 📄 コードレビュー時

- [ ] 正確性: 仕様を満たし、バグがないか？
- [ ] セキュリティ: 脆弱性や入力バリデーション漏れはないか？
- [ ] パフォーマンス: N+1問題やメモリリークはないか？
- [ ] テスト: 十分なテストカバレッジがあるか？
- [ ] ドキュメント: コメントやREADMEが更新されているか？
- [ ] 設計: コンストラクタは「インターフェースを受け入れ、具象を返す」パターンに従っているか？

#### 🔧 リリース前

- [ ] CI/CD: すべてのテストが成功しているか？
- [ ] API: 破壊的変更がないかチェック済みか？
- [ ] ログ: 総合テストでログ出力を確認したか？
- [ ] メトリクス: パフォーマンスメトリクスを確認したか？
